ctmc

// Global Constants
const MAX_QUEUE = MAX_URL_DNS_REQUESTS + 1;
const MAX_URL_DNS_REQUESTS;
const double popularity;
const query_id_range = 65536;
const port_id_range;
const N = query_id_range * port_id_range;
const guess;
const double requests_rate = 1;
const other_legitimate_requests_rate;
formula cache_poisoned = correct_guess = true;


module intruder_client
	// -- States
	trials : [0..MAX_URL_DNS_REQUESTS] init 0;
	resolver_replies : [0..MAX_URL_DNS_REQUESTS] init 0;

	// -- Transitions

	// 1. Send Request: The Intruder initiates the resolution for a specific domain.
    	// This increments the 'trials' counter.
	[DNS_Request_Client_To_Resolver] trials < MAX_URL_DNS_REQUESTS -> requests_rate : (trials' = trials + 1);

	// 2. Receive Reply: The resolver (victim) sends an answer back.
    	// This marks the end of one specific query cycle.
	[DNS_Response_Resolver_To_Client] resolver_replies < trials -> (resolver_replies' = resolver_replies + 1);

	// 3. Termination: When all planned requests are finished, the module enters a final idle loop.
	[] resolver_replies = MAX_URL_DNS_REQUESTS -> true;
endmodule

module client_server 
	// -- States
	ttl : [0..2] init 2;
	client_queue : [0.. MAX_QUEUE] init 0;
	root_queue : [0.. MAX_QUEUE] init 0;
	domain_queue : [0.. MAX_QUEUE] init 0;
	responses_queue : [0.. MAX_QUEUE] init 0;

	// -- Variables
	query_to_root_server: bool init false;
	query_to_domain_server: bool init false;
	answer_from_domain_received: bool init false;
	correct_guess: bool init false;

	// -- Transitions

	// 1. Client Request (Merged Hit/Miss Logic)
	[DNS_Request_Client_To_Resolver] (client_queue < MAX_QUEUE) & (responses_queue < MAX_QUEUE) & (root_queue < MAX_QUEUE) -> 
    		// Branch 1: Cache Hit (Probability: popularity/10)
    		(popularity / 10) : (client_queue' = client_queue + 1) & (ttl' = 1) & (responses_queue' = responses_queue + 1)
    		+
    		// Branch 2: Cache Miss (Probability: 1 - popularity/10)
    		(1 - (popularity / 10)) : (client_queue' = client_queue + 1) & (ttl' = 0) & (root_queue' = root_queue + 1);
	
	// 2. Query Root
	[DNS_Request_Resolver_To_Root] (client_queue > 0) & (root_queue > 0) 
		-> (query_to_root_server' = true);

	// 3. Root Responds -> Move to Domain Queue
	[DNS_Response_Root_To_Resolver] (root_queue > 0) & (domain_queue < MAX_QUEUE)
 		-> (root_queue' = root_queue - 1) & (domain_queue' = domain_queue + 1) & (query_to_root_server' = false);

	// 4. Query Domain (Opens Vulnerability Window)
	[DNS_Request_Resolver_To_Domain] domain_queue > 0 -> (query_to_domain_server' = true);

	// 5. Domain Responds (Closes Window)
	[DNS_Response_Domain_To_Resolver] (domain_queue > 0) & (responses_queue < MAX_QUEUE) & (correct_guess = false) 
		-> (domain_queue' = domain_queue - 1) & (responses_queue' = responses_queue + 1) & (query_to_domain_server' = false) & (answer_from_domain_received' = true);
	
	// 6. Reply to Client
	[DNS_Response_Resolver_To_Client] (responses_queue > 0) & (client_queue > 0) 
		-> (client_queue' = client_queue - 1) & (responses_queue' = responses_queue - 1);
	

	// --- Race Condition (Attack) ---
	[Guess] (correct_guess = false) & (query_to_domain_server = true) -> 
        	// Branch 1: The guess matches (Probability 1/N)
        	1 / N : (correct_guess' = true) 
        	+
        	// Branch 2: The guess is wrong (Probability (N-1)/N)
        	(N - 1) / N : (correct_guess' = false);
	
	// Sink State
	[] cache_poisoned = true -> true;
endmodule

module root_server
	// States
	root_state : [0..1] init 0;

	// Transitions

	// 1. Receive Request: A query arrives from the Victim Resolver.
	[DNS_Request_Resolver_To_Root] root_state = 0 -> (root_state' = 1);

	// 2. Send Reply: The Root Server immediately responds, moving the resolver to the next step (Domain Server).
	[DNS_Response_Root_To_Resolver] root_state = 1 -> (root_state' = 0);
endmodule

module target_domain_server
	// -- States
	domain_state : [0..1] init 0;

	// -- Variables
	denial_of_service : bool init false;
	
	// -- Transitions

	// 1. Receive Request: The Victim Resolver asks "Where is example.com?".
    	// This opens the 'Race Window'. The Intruder starts guessing NOW.
	[DNS_Request_Resolver_To_Domain] domain_state = 0 -> (domain_state' = 1);

	// 2. Legitimate Response (The "Good" Ending):
    	// The server processes the specific request from our Victim Resolver.
        // This transition closes the 'Race Window' (Intruder stops guessing).
	[DNS_Response_Domain_To_Resolver] domain_state = 1 -> 1/(other_legitimate_requests_rate) : (domain_state' = 0);

	// 3. Busy Work ("Noise"):
    	// The server is busy answering OTHER users on the internet.
    	// This keeps the server in state 1 (busy), effectively delaying the response to our Victim.
	[DNS_Response_Domain_Other_Request] domain_state = 1 -> (other_legitimate_requests_rate - 1)/other_legitimate_requests_rate : (domain_state' = 1);
endmodule

module intruder_server
	// -- States
	state_IS : [0..1] init 0;
	
	// -- Transitions

	// 1. Start Attack: Triggered when the Victim Resolver queries the Domain Server.
    	// The 'Race Window' is now open.
	[DNS_Request_Resolver_To_Domain] state_IS = 0 -> (state_IS' = 1);

	// 2. Firing Loop (The "Machine Gun"):
    	// Fires guesses at rate 'guess'.
    	// The success/failure logic is handled by the Victim Resolver module via probabilistic split.
	[Guess] state_IS=1 -> guess : (state_IS'=1);

	// 3. Stop Attack: Triggered when the Victim Resolver receives the legitimate answer.
    	// The 'Race Window' is closed. The attack failed for this specific query.
	[DNS_Response_Domain_To_Resolver] state_IS = 1 -> (state_IS' = 0);
endmodule